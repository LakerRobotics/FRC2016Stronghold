// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5053.FRC2016Stronghold.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc5053.FRC2016Stronghold.Robot;
import org.usfirst.frc5053.FRC2016Stronghold.RobotMap;

import com.analog.adis16448.frc.ADIS16448_IMU;

/**
 *
 */
public class DriveStraighToTarget extends ArcadeDriveStrightPID{

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveStraighToTarget() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    	super(Robot.visionHandler.getGoalOffset());
    	this.maxspeed= 10.0*(360/60);
    	this.ramp = 10;
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.rightShooter);
        requires(Robot.leftShooter);
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	super.initialize();
    	double distance = Robot.visionHandler.getDistance();
    	double shooterSpeed = getShooterSpeed(distance);
    	double shooterAngle = getShooterAngle(distance);

        Robot.rightShooter.enable();
        Robot.rightShooter.setSetpoint(-shooterSpeed);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZE
        Robot.leftShooter.enable();
        Robot.leftShooter.setSetpoint(-shooterSpeed);

    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	SmartDashboard.putNumber("IMU_X_Axis", RobotMap.IMU.getAngleX());
//    	SmartDashboard.putNumber("IMU_Y_Axis", Robot.imuBoard.getAngleY());
//    	SmartDashboard.putNumber("IMU_Z_Axis", Robot.imuBoard.getAngleZ());
    	
    	double targetOffset = Robot.visionHandler.getGoalOffset();
    	double start = RobotMap.gyroToUse.getAngle();
    	
    	m_targetAngle = start + targetOffset;
    	this.rotationSpeedProfile.setTargetDistance(m_targetAngle);
    	     	
    	
    	double distance = Robot.visionHandler.getDistance();
    	double shooterSpeed = getShooterSpeed(distance);
        Robot.rightShooter.setSetpoint(-shooterSpeed);
        Robot.leftShooter.setSetpoint(-shooterSpeed);

    	double shooterAngle = getShooterAngle(distance);
    	
    	
    }

    // Make this return true when this Command no longer needs to run execute()
 //UseParent   protected boolean isFinished() {
 //UseParent       return false;
 //UseParent   } 

    // Called once after isFinished returns true
 //UseParent   protected void end() {
 //UseParent   }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	super.interrupted();
    	// Turn off PID control and shut down the motors
    	Robot.rightShooter.disable();
    	RobotMap.rightShooterRightShooterMotor.set(0);

    	Robot.leftShooter.disable();
    	RobotMap.leftShooterLeftShooterMotor.set(0);
    }
    
	public double getShooterSpeed(double distance) {
        // If shooting under 4ft is too low then increase this number.
		// Take an estimate about how short it was in height and go to the spreadsheet and use the excel menu DATA>>What-If Analysis>>Goal seek to find the new desired speed.
		// the goal seek should seek a the new height (e.g. the original height(8.5ft) plus how low the ball was from the top of the goal).
		// Example if the shot was 1.5ft low then the goal seek should look to have cell K12 set to 10ft while changing cell F12.  Note 10ft is the 8.5 + 1.5 how much it was off by.

		double lowSpeed = 1500;  // If shooting close is to low Increase this number.  Take an estimate about how low it is and go to the spreadsheet and is excel goal seek to find the new desired speed that will get the the original heigh t(8.5ft) to the 8.5 + how much it was off by

		double highSpeed = 2500;
		
		if(distance < 4) {
            return lowSpeed;
		}
		else if(distance > 7) {
			return highSpeed;
		}
		else {
			return lowSpeed + (distance*((highSpeed-lowSpeed)/(7-4)) );// Originaly 800 + (distance *566.667
		}
	}

	public double getShooterAngle(double distance) {
		if(distance < 4) {
            return -1.3677 * (distance * distance) + (0.6361 * distance) + 86.144;
		}
		else if(distance > 7) {
			return 0.0829 * (distance * distance) - (3.7229 * distance) + 65.48;
		}
		else {
			return 1.3106 * (distance * distance) - (21.546 * distance) + 131.45;
		}
	}

}
