// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5053.FRC2016Stronghold.commands;

import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc5053.FRC2016Stronghold.MotionControlHelper;
import org.usfirst.frc5053.FRC2016Stronghold.MotionControlPIDController;
import org.usfirst.frc5053.FRC2016Stronghold.Robot;
import org.usfirst.frc5053.FRC2016Stronghold.RobotMap;

/**
 *
 */
public class ArmSetpointsRateControl extends ArmSetpoints {
	
	double m_targetPotentiameterValue = NEUTRAL;
	double targetTolerance = 0.005 ; //

    double     ramp = 5 * 0.002471153; //First number is inches, second convert inches to change in String Pot readings
                                       // Also note, the code ramps at the "start" up from 50% of the maxspeed to the maxSpeed, and as approaches target from maxspeed to zero
    double maxspeed = 5 * 0.01048 ; //first number is RPM, second number 0.01048 convert to change in String potentiometer value per second
                                    // RPM calculated max possible is 12.5 which is probably not achievable since it assumes zero friction loss
                                    // if RPM is set to high, then the arm will travel as fast as possible, but need to make sure rampdown
    								// slows to stop in stead of oscillating
                                    // 
    double    start =   1; // this can be any number since we dont care about a jump at the start
    MotionControlHelper rotationSpeedProfile; 
    
    final double Kp = maxspeed/10; // so at 1/denominator ie 10% offset from the maxspeed the power will reach the max
    final double Ki = 0.0005;
    final double Kd = 0.0;
    MotionControlPIDController armSpeedPID;
 
    private double mm_targetSetpoint;
    
    public ArmSetpointsRateControl(double setpoint) {
    	super(setpoint);
    	mm_targetSetpoint = setpoint;
    }

    // Called just before this Command runs the first time
    protected void initialize() {
        //Robot.arm.enable();
        //Robot.arm.setSetpoint(m_setpoint);

        SmartDashboard.putString("ArmSetpointRateControlCodeLocation","entered initialize()");
	   	
//	    mcPID.free();
    //set so the PIDSource will return the current position (i.e. displacement)
        RobotMap.armArmStringPot.setPIDSourceType(PIDSourceType.kDisplacement);
        start = RobotMap.armArmStringPot.pidGet();
        rotationSpeedProfile = new MotionControlHelper(mm_targetSetpoint, ramp, maxspeed, start, 
    		(PIDSource) RobotMap.armArmStringPot,
    		RobotMap.armArmMotor);
        armSpeedPID = new MotionControlPIDController(Kp,Ki,Kd, rotationSpeedProfile );
        armSpeedPID.setOutputRange(-0.10, 0.10);
        armSpeedPID.enable();
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() 
    {
        SmartDashboard.putString("ArmSetpointRateControlCodeLocation","entered execute()");
        SmartDashboard.putNumber("ArmSetpointRateControlTarget Setpoint", mm_targetSetpoint);
        SmartDashboard.putNumber("ArmSetpointRateControl Arm_String_Pot_Reading", RobotMap.armArmStringPot.get());
        System.out.println("ArmSetpointRateControlCodeLocation "+"entered execute()");
    	// get current Angle to report on
        //Ensure the PIDSource will return the current position (i.e. displacement)
        RobotMap.armArmStringPot.setPIDSourceType(PIDSourceType.kDisplacement);
        double currentAngle = RobotMap.armArmStringPot.pidGet(); 
        SmartDashboard.putNumber("ShooterAimSetPoints Current angle",currentAngle);
        SmartDashboard.putNumber("ShooterAimSetPoints mm_targetAngle",mm_targetSetpoint);
        
        //set so the imuTilt will return the current tilt angle rate
        RobotMap.armArmStringPot.setPIDSourceType(PIDSourceType.kRate);
        double currentRate = RobotMap.armArmStringPot.pidGet(); 
        //set so the imuTilt will return the current tilt angle
        RobotMap.armArmStringPot.setPIDSourceType(PIDSourceType.kDisplacement);

        SmartDashboard.putNumber("ShooterAimSetPoints Actual Rate",currentRate);
        SmartDashboard.putNumber("ShooterAimSetPoints Target Rate",rotationSpeedProfile.getTargetSpeed(currentAngle));
        SmartDashboard.putNumber("ShooterAimSetPoints Time",this.timeSinceInitialized());
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        SmartDashboard.putString("ArmSetpointRateControlCodeLocation","entered isFinished()");
        
    	if(Math.abs(RobotMap.imuTilt.pidGet()-mm_targetSetpoint)<targetTolerance) { 
//       		rotationSpeedPID.disable();
       		System.out.println("ShooterAimSetpoints Finished true");
// lets let it continually update the angle, trying to get better       		
//       	  	RobotMap.shooterAimMotor.set(0);; 
       		return  true;
       	}
       	else{
               return false;
       	}

    }
       // Called once after isFinished returns true
        protected void end() {
            SmartDashboard.putString("ArmSetpointRateControlCodeLocation","entered end()");
            System.out.println("ArmSetpointRateControlCodeLocation "+"entered end()");
//       	rotationSpeedPID.disable();
        }

        // Called when another command which requires one or more of the same
        // subsystems is scheduled to run
        protected void interrupted() {
            SmartDashboard.putString("ArmSetpointRateControlCodeLocation","entered interrupted()");
            System.out.println("ArmSetpointRateControlCodeLocation "+"entered interrupted()");
            RobotMap.shooterAimMotor.set(0);//
           	armSpeedPID.disable();
           	end();
        }
     
															
    
}
