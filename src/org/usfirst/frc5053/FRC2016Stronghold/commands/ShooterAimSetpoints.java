// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5053.FRC2016Stronghold.commands;

import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc5053.FRC2016Stronghold.MotionControlHelper;
import org.usfirst.frc5053.FRC2016Stronghold.MotionControlPIDController;
import org.usfirst.frc5053.FRC2016Stronghold.Robot;
import org.usfirst.frc5053.FRC2016Stronghold.RobotMap;

/**
 *
 */
public class ShooterAimSetpoints extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	   // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	double m_targetTiltAngle = 90;//default in degrees
	double targetTolerance = 1 ; //degrees

    double     ramp =  30; //degrees ramps up from 50% of the top speed to the maxSpeed, and from maxspeed to zero
    double maxspeed = 7.5*(360/60) ; //360/60 converts the first numbers which is in RPM to degrees/second The Window motors can do about 75 RPM
    double    start =   180; //degrees just tell the code we started on the other side, so it will go to full speeed (we don't need a slow start, a fast start is fine)
    MotionControlHelper rotationSpeedProfile; 
    
    final double Kp = 1d/(maxspeed*100); // so if we are off by maxspeed then we should get 100% power
    final double Ki = 0.000;// removed 0.0005, so only P controlling, no error over time cotroling, again general approach up P till get waiving the back off
    final double Kd = 0.0;
    MotionControlPIDController tiltSpeedPID;
 

    	double minAngle = 0;
    	double maxAngle = 90;
    	
    public ShooterAimSetpoints(double desiredTiltAngle) {
        SmartDashboard.putString("ShooterAimSetPointsCodeLocation","entered ShooterAimSetPoints("+desiredTiltAngle+")");
	       // Use requires() here to declare subsystem dependencies
	       // eg. requires(chassis);
        m_targetTiltAngle = desiredTiltAngle;
//        if (m_targetTiltAngle < minAngle ) m_targetTiltAngle = minAngle;
//        if (m_targetTiltAngle > maxAngle ) m_targetTiltAngle = maxAngle;
        
	    	System.out.println("ShooterAimSetPoints targetTiltAngle "+m_targetTiltAngle+".");
	        rotationSpeedProfile = new MotionControlHelper(m_targetTiltAngle, ramp, maxspeed, start, 
	        		(PIDSource) RobotMap.imuTilt,
	        		RobotMap.shooterAimShooterAimMotor);
	        tiltSpeedPID = new MotionControlPIDController(Kp,Ki,Kd, rotationSpeedProfile );
	    	tiltSpeedPID.setOutputRange(-.2, 0.7);
	    	
	    	

	       // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooterAim);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
         
	 }
    
    public void setSetpoint(double targetTiltAngle){
    	m_targetTiltAngle = targetTiltAngle;
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

    // Called just before this Command runs the first time
    protected void initialize() {
    	//m_targetTiltAngle = (90*(1-(Robot.oi.debugJoystick.getZ()+1)/2));
        SmartDashboard.putString("ShooterAimSetPointsCodeLocation","entered initialize()");//    	   	RobotMap.gyroToUse.reset();
    	rotationSpeedProfile.setTargetDistance(m_targetTiltAngle);   	
//    	    mcPID.free();
        //set so the imuTilt will return the current tilt angle
        RobotMap.imuTilt.setPIDSourceType(PIDSourceType.kDisplacement);
        
        //start = RobotMap.imuTilt.pidGet();
    	tiltSpeedPID.enable();
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        SmartDashboard.putDouble("Debug Joystick Z Value", 90*(Robot.oi.debugJoystick.getZ()+1)/2);
        SmartDashboard.putString("ShooterAimSetPointsCodeLocation","entered execute()");
        System.out.println("ShooterAimSetPointsCodeLocation "+"entered execute()");
    	// get current Angle to report on
//    	double currentAngle = RobotMap.IMU.getAngleX(); // RGT 20160408 this is from startup angle or could be reset
//        double currentAngle = RobotMap.IMU.getRoll(); // RGT 20160408 Think this should be absolute relative to the floor
        //Ensure the imuTilt will return the current tilt angle
        RobotMap.imuTilt.setPIDSourceType(PIDSourceType.kDisplacement);
        double currentAngle = RobotMap.imuTilt.pidGet(); // RGT 20160408 Think this should be absolute relative to the floor
        SmartDashboard.putNumber("ShooterAimSetPoints Current angle",currentAngle);
        SmartDashboard.putNumber("ShooterAimSetPoints TargetTiltAngle",m_targetTiltAngle);
        
        //set so the imuTilt will return the current tilt angle rate
        RobotMap.imuTilt.setPIDSourceType(PIDSourceType.kRate);
        double currentRate = RobotMap.imuTilt.pidGet(); // RGT 20160408 Think this should be absolute relative to the floor
        //set so the imuTilt will return the current tilt angle
        RobotMap.imuTilt.setPIDSourceType(PIDSourceType.kDisplacement);

        SmartDashboard.putNumber("ShooterAimSetPoints TiltRotation Actual Rate",currentRate);
        SmartDashboard.putNumber("ShooterAimSetPoints TiltRotation Target Rate",rotationSpeedProfile.getTargetSpeed(currentAngle));
        SmartDashboard.putNumber("ShooterAimSetPoints Time",this.timeSinceInitialized());
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        SmartDashboard.putString("ShooterAimSetPointsCodeLocation","entered isFinished()");
        
    	if(Math.abs(RobotMap.imuTilt.pidGet()-m_targetTiltAngle)<targetTolerance) { 
//       		rotationSpeedPID.disable();
       		System.out.println("ShooterAimSetpoints Finished true");
// lets let it continually update the angle, trying to get better       		
//       	  	RobotMap.shooterAimMotor.set(0);; 
       		return  true;
       	}
       	else{
               return false;
       	}

    }

    // Called once after isFinished returns true
    protected void end() {
        SmartDashboard.putString("ShooterAimSetPointsCodeLocation","entered end()");
        System.out.println("ShooterAimSetPointsCodeLocation "+"entered end()");
        RobotMap.shooterAimShooterAimMotor.set(0);//
      	tiltSpeedPID.disable();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
        SmartDashboard.putString("ShooterAimSetPointsCodeLocation","entered interrupted()");
        System.out.println("ShooterAimSetPointsCodeLocation "+"entered end()");
        RobotMap.shooterAimShooterAimMotor.set(0);//
       	tiltSpeedPID.disable();
    }
}